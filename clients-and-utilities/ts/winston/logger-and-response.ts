/**
 * @file To provide a standard for logger and response.
 * @summary Logger and response function that use Winston.
 * @description This file contains the implementation of Logger and Response module that utilize Winston package.
 */

/**
 * OVERVIEW
 * This util file contain the response & logger for BFF
 * The reason we are combining both of this util into 1 file is because
 *  1. We want to have a consistent requestId for both response & logger
 *     and pass back to FE for debugging purpose
 *  2. It will causes circular dependecy when logger & response are separated into different files
 *     as we are trying to set a global requestId in the logger/response
 *  3. We want to log the response that we pass to FE for the okResponse/errResponse
 *
 * @example
 * // It is recommendable to import the file wholly, instead of per function.
 * // So that, we able to standardize the usage.
 * import lar from 'logger-and-response.ts'
 * lar.info("Warning", {key: "value"})
 */

import {
  APIGatewayProxyEvent,
  APIGatewayProxyResult,
  Context,
} from "aws-lambda";
import { inspect } from "util";
import winston, { format, createLogger } from "winston";
import { ConvertErrorObject, CustomError } from "./interfaces";

inspect.defaultOptions.depth = null;

/* The `customFormatter` is a custom formatter function that is used to format the log messages
generated by the logger. It takes an object as a parameter, which represents a log message, and
returns a formatted string. */
const customFormatter = format.printf((object) => {
  return `[${object.level.toUpperCase()}] - ${object.message}: ${JSON.stringify(
    object
  )}`;
});

let logger: winston.Logger = createLogger({
  level: process.env.LOG_LEVEL || "info",
  format: winston.format.combine(winston.format.splat(), customFormatter),
  transports: [new winston.transports.Console()],
  defaultMeta: {
    requestId: null,
    service: null,
    timestamp: new Date().getTime(),
  },
});
let requestId: string | null = null;

/**
 * The function `okResponse` returns a standardized API response with a success status code, message,
 * and optional data.
 * @param {string} message - A string that represents the message to be included in the response.
 * @param {object | Record<string, object>} data - The `data` parameter is an optional parameter that
 * can accept either an object or a record of string keys and object values. It is used to pass
 * additional data along with the response message.
 * If you want to pass other value in data, put it inside an object.
 * To make sure in future, you can add additional key value pair.
 * @param [statusCode=200] - The `statusCode` parameter is an optional parameter that specifies the
 * HTTP status code to be returned in the response. If not provided, it defaults to 200 (OK).
 * @returns an object of type `APIGatewayProxyResult`.
 *
 * @example
 * // Example 1: Creating a success response with data
 * return okResponse("Success", { key: "value" });
 *
 * // Example 2: Creating a success response without data
 * return okResponse("Success");
 */
function okResponse(
  message: string,
  data: object | Record<string, object> | null = {},
  statusCode = 200
): APIGatewayProxyResult {
  logger.info(message, data);
  return {
    statusCode: statusCode,
    headers: {
      "Access-Control-Allow-Origin": "*",
      "Access-Control-Allow-Credentials": true,
    },
    body: JSON.stringify({
      requestId: requestId,
      statusCode: 200,
      message: message,
      data: data,
    }),
  };
}

/**
 * The `errResponse` function is a TypeScript function that generates a standardized error response for
 * an API Gateway proxy.
 * @param {number} statusCode - The `statusCode` parameter is a number that represents the HTTP status
 * code of the response.
 * @param {string} message - The `message` parameter is a string that represents the error message to
 * be returned in the response. It provides a description of the error that occurred.
 * @param {Error | object | CustomError} errorObject - The `errorObject` parameter is an optional parameter that can
 * be either an `Error` object or a generic object. It is used to provide additional information about
 * the error that occurred. If it is an `Error` object, the function extracts the `name`, `message`,
 * and `stack`
 * @returns an object of type `APIGatewayProxyResult`.
 *
 * @example
 * // Example 1: Creating an error response with a standard error object
 * return errResponse(400, "Bad Request", new Error("Invalid input"));
 *
 * // Example 2: Creating an error response with a custom error object
 * const customError = { code: 500, description: "Internal Server Error" };
 * return errResponse(500, "Server Error", customError);
 *
 * // Example 3: Creating an error response with the minimum required parameters
 * return errResponse(404, "Not Found");
 */
function errResponse(
  statusCode: number,
  message: string,
  errorObject: Error | CustomError | object = {}
): APIGatewayProxyResult {
  const error = convertErrorObject(errorObject);
  logger.error(message, error.logger);

  return {
    statusCode: statusCode,
    headers: {
      "Access-Control-Allow-Origin": "*",
      "Access-Control-Allow-Credentials": true,
    },
    body: JSON.stringify({
      requestId: requestId,
      statusCode: statusCode,
      message: message,
      error: error.response,
    }),
  };

  function convertErrorObject(
    errorObject: Error | object | CustomError
  ): ConvertErrorObject {
    let loggerError: CustomError | object;
    let responseError: Omit<CustomError, "stack"> | object;
    // Using duck typing to check for the errorObject
    if (
      errorObject &&
      (errorObject as Error | CustomError).name &&
      (errorObject as Error | CustomError).stack &&
      (errorObject as Error | CustomError).message
    ) {
      loggerError = {
        name: (errorObject as Error | CustomError).name,
        message: (errorObject as Error | CustomError).message,
        stack:
          (errorObject as Error | CustomError).stack || "No stack provided",
      };

      responseError = {
        name: (errorObject as Error | CustomError).name,
        message: (errorObject as Error | CustomError).message,
      };
    } else {
      loggerError = errorObject;
      responseError = errorObject;
    }

    return { logger: loggerError, response: responseError };
  }
}

/**
 * It initializes the logger and sets the requestId
 * @param [event=null] - The event object that triggered the lambda function.
 * @param [context=null] - This is the context object that is passed to the Lambda function. It
 * contains information about the Lambda function and the execution environment.
 * { error: 0, warn: 1, info: 2, http: 3, verbose: 4, debug: 5, silly: 6}
 */
function initContext(
  event: object | APIGatewayProxyEvent,
  context: Context
): void {
  requestId = context.awsRequestId;

  logger = createLogger({
    level: process.env.LOG_LEVEL || "info",
    format: winston.format.combine(winston.format.splat(), customFormatter),
    transports: [new winston.transports.Console()],
    defaultMeta: {
      requestId: context?.awsRequestId || null,
      service: context?.functionName || null,
      timestamp:
        (event as APIGatewayProxyEvent)?.requestContext?.requestTimeEpoch ||
        new Date().getTime(),
    },
  });

  (event as APIGatewayProxyEvent)?.requestContext
    ? logger.info("Request Context", {
        identity: (event as APIGatewayProxyEvent).requestContext,
        payload: {
          queryStringParameters:
            (event as APIGatewayProxyEvent)?.queryStringParameters || null,
          pathParameters:
            (event as APIGatewayProxyEvent)?.pathParameters || null,
          body: (event as APIGatewayProxyEvent)?.body || null,
        },
      })
    : logger.info("Event information", { event });
}

/**
 * The function "error" logs an error message along with an optional error object.
 * @param {string} message - A string that represents the error message.
 * @param {object | Record<string, object>} errorObject - The `errorObject` parameter is an optional
 * parameter that accepts an object or a record of objects. It is used to provide additional
 * information about the error that occurred. This can be useful for logging purposes or for providing
 * more context about the error.
 *
 * Read file overview on how to import
 *
 * @example
 * // Example 1: Logging a simple error message
 * lar.error("This is an error message");

 * // Example 2: Logging an error message with additional error information
 * const errorInfo = {
 *   key1: "value1",
 *   key2: { nestedKey: "nestedValue" },
 * };
 * lar.error("Error info", errorInfo);
 */
function error(
  message: string,
  errorObject: object | Record<string, object> = {}
): void {
  logger.error(message, errorObject);
}

/**
 * The function "warn" logs a warning message along with an optional warning object.
 * @param {string} message - A string representing the warning message.
 * @param {object | Record<string, object>} warningObject - The `warningObject` parameter is an
 * optional parameter that accepts an object or a record of string keys and object values. It is used
 * to provide additional information or context for the warning message.
 *
 * Read file overview on how to import
 *
 * @example
 * // Example 1: Logging a simple warn message
 * lar.warn("This is a warn message");

 * // Example 2: Logging a warn message with additional warning information
 * const warnInfo = {
 *   key1: "value1",
 *   key2: { nestedKey: "nestedValue" },
 * };
 * lar.warn("Warn info", warnInfo);
 */
function warn(
  message: string,
  warningObject: object | Record<string, object> = {}
): void {
  logger.warn(message, { params: warningObject });
}

/**
 * The "info" function logs a message along with an optional object parameter.
 * @param {string} message - A string that represents the message to be logged.
 * @param {object | Record<string, object>} infoObject - The `infoObject` parameter is an optional
 * parameter that accepts an object or a record of string keys and object values. It is used to provide
 * additional information or parameters related to the `message`.
 *
 * Read file overview on how to import
 *
 * @example
 * // Example 1: Logging a simple info message
 * lar.info("This is an info message");

 * // Example 2: Logging an info message with additional information
 * const info = {
 *   key1: "value1",
 *   key2: { nestedKey: "nestedValue" },
 * };
 * lar.info("Info logger", info);
 */
function info(
  message: string,
  infoObject: object | Record<string, object> = {}
): void {
  logger.info(message, { params: infoObject });
}

/**
 * The `verbose` function logs a message with optional additional verbose information.
 * @param {string} message - A string that represents the message to be logged.
 * @param {object | Record<string, object>} verboseObject - The `verboseObject` parameter is an
 * optional parameter that accepts an object or a record of string keys and object values. It is used
 * to provide additional information or context to the `logger.verbose` method.
 *
 * Read file overview on how to import
 *
 * @example
 * // Example 1: Logging a simple verbose message
 * lar.verbose("This is a verbose message");

 * // Example 2: Logging a verbose message with additional verbose information
 * const verboseInfo = {
 *   key1: "value1",
 *   key2: { nestedKey: "nestedValue" },
 * };
 * lar.verbose("Verbose info", verboseInfo);
 */
function verbose(
  message: string,
  verboseObject: object | Record<string, object> = {}
): void {
  logger.verbose(message, { params: verboseObject });
}

/**
 * The `debug` function logs a message and an optional debug object to a logger.
 * @param {string} message - A string that represents the debug message to be logged.
 * @param {object | Record<string, object>} debugObject - The `debugObject` parameter is an optional
 * parameter that accepts an object or a record of string keys and object values. It is used to provide
 * additional debugging information related to the `message`.
 *
 * Read file overview on how to import
 *
 * @example
 * // Example 1: Logging a simple debug message
 * lar.debug("This is a debug message");

 * // Example 2: Logging a debug message with additional debugging information
 * const debugInfo = {
 *   key1: "value1",
 *   key2: { nestedKey: "nestedValue" },
 * };
 * lar.debug("Debugging info", debugInfo);
 */
function debug(
  message: string,
  debugObject: object | Record<string, object> = {}
): void {
  logger.debug(message, { params: debugObject });
}

export default {
  okResponse,
  errResponse,
  error,
  warn,
  info,
  verbose,
  debug,
  initContext,
};
